<div id="wrapper_<?= $this->chartId ?>" class="chart-wrapper actuell-data-container" >
<?php
// !!!! Achtung: Dieses Template benötigt das JS-Template js_coh_chart_script im Layout! Beim Deinstallieren den Eintrag aus dem Layout entfernen!
?>
<?php 
    if ($this->syncError) {
        echo '<div class="error">'.$this->syncError.'</div>';
    } 
    //var_dump($this->data);
    echo '<p>';
//    echo 'akt. Werte vom:'.$this->lastPullSync."\n";
    echo '<br>push Tabellen am:'.$this->lastPullSync."\n";
    echo '<br>Stand vom: '.$this->lastSensorChange."</p>";
    // nur wenn Status NICHT OK
    if ($this->lastSensorChangeStatus !== 'OK') {
        echo '<div class="error">';
        echo ' ('.$this->lastSensorChangeStatus.')';
        echo '</div>';
    }
    
?>
  <script>
//@ sourceURL=coh_dashboard_inline.js
    const chartId = '<?= $this->chartId ?>';
    const data = <?= json_encode($this->data ?? [], JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_QUOT | JSON_HEX_AMP) ?>;


    const sensorConfig = [

      { sensorId: 'IQbattery_94_battery_stateOfCharge',             icon: 'gauge',  iconType: 'gauge', iconSize: 50, color: 'green',textColor: 'green'},
      { sensorId: 'IQinverter_94_inverter_pvPower',                 icon: 'bs:bi-sun-fill', iconSize: 24, iconColor: 'green',textColor: 'blue' },
      { sensorId: 'IQSolar_harmonized_work_Solar_gesamt',                 icon: 'bs:bi-sunset', iconSize: 24, iconColor: 'green',textColor: 'blue' },
      { sensorId: 'IQSolar_harmonized_work_Solar_Tag',                 icon: 'bs:bi-sunset', iconSize: 24, iconColor: 'green',textColor: 'blue' },
      { sensorId: 'IQinverter_94_inverter_selfConsumptionPower',    icon: 'bs:bi-house', iconSize: 24, iconColor: 'green' },      
      //{ sensorId: 'IQinverter_94_inverter_selfConsumptionPower',    icon: 'fa-regular:fa-house', iconSize: 24, iconColor: 'green' },      
      { sensorId: 'IQBatt_Temp',                                    icon: 'bs:bi-thermometer', iconSize: 24, iconColor: 'green' },
      { sensorId: 'IQbattery_94_battery_mode',                      icon: 'bs:bi-thermometer', iconSize: 24, iconColor: 'green' },
      { sensorId: 'IQbattery_94_battery_power',                     icon: 'bs:bi-battery-full', iconSize: 24, iconColor: 'green' },
      { sensorId: 'ZWZZaehlerPower',                                icon: 'bs:bi-sign-intersection-y', iconSize: 24, iconColor: 'red' },
      { sensorId: 'ZWZZaehlerTotalPVEnergie',                       icon: 'bs:bi-sign-intersection-y', iconSize: 24, iconColor: 'red' },

      { sensorId: 'Kommentar',                                      iconType: 'togglestart', iconSize: 24, sensorTitle: ' Tasmota SWR Zähler',textColor: 'blue', sensorValue: 'Daten' },
      { sensorId: 'TS_Power',                                       icon: 'bs:bi-lightning-fill', iconSize: 24, iconColor: 'green' },
      { sensorId: 'TS_E_in_108',                                    icon: 'bs:bi-lightning-fill', iconSize: 24, iconColor: 'green' },
      { sensorId: 'TS_E_out_208',                                   icon: 'bs:bi-lightning-fill', iconSize: 24, iconColor: 'green' },
      { sensorId: 'Kommentar',                                      iconType: 'toggleend' },

      { sensorId: 'Kommentar',                                      iconType: 'togglestart', iconSize: 24, sensorTitle: ' Heizstab Daten',textColor: 'blue', sensorValue: 'open' },
      { sensorId: 'ELaktTemp1',                                     icon: 'bs:bi-thermometer', iconSize: 24, iconColor: 'green' },
      { sensorId: 'ELaktTemp2',                                     icon: 'bs:bi-thermometer', iconSize: 24, iconColor: 'green' },
      { sensorId: 'ELaktboostactive',                               icon: 'bs:bi-circle-fill', iconSize: 24, iconColor: 'green' }, 
      { sensorId: 'ELaktPwr',                                       icon: 'bs:bi-lightning-fill', iconSize: 24, iconColor: 'green' },
      { sensorId: 'Kommentar',                                      iconType: 'toggleend' },

      { sensorId: 'RaspberryHeizstabServerProtokoll',               icon: 'bs:bi-list-ul',  iconType: 'toggle', iconSize: 24, iconColor: 'green', sensorTitle: 'HeizstabServerProtokoll' },
      { sensorId: 'RaspberryHeizstabServerIntervall',               icon: 'bs:bi-square', iconSize: 24, iconColor: 'green' },

      { sensorId: 'Kommentar',                                      iconType: 'togglestart', iconSize: 24, sensorTitle: ' Raspberry Systemdaten',textColor: 'blue', sensorValue: 'Systemdaten'},
      { sensorId: 'RaspberryCheckHeizstabServer',                   icon: 'bs:bi-bullseye', iconSize: 24, iconColor: 'green' },
      { sensorId: 'RaspberrycheckSensorCollectorServer',            icon: 'bs:bi-circle-fill', iconSize: 24, iconColor: 'green' },
      { sensorId: 'RaspberrycheckPlattenbelegung',                  icon: 'bs:bi-sd-card', iconSize: 24, iconColor: 'green'},
      { sensorId: 'Kommentar',                                      iconType: 'toggleend' }
    
            
    ];


    sensorConfig.forEach((config, index) => {                // index ist der positionsindex in sensorConfig
       let sensor = data[config.sensorId];
       config.extraText = '';
        if (sensor === undefined) {
//console.log("-------------------------------sensor suche "+config.sensorID);
            // Spezialfall: ZWZZaehlerPower berechnen
            if (config.sensorId === 'Kommentar') {
                sensor = { time: '', label: config.sensorId,
                sensorTitle: config.sensorTitle ?? '', sensorId: config.sensorId, sensorValue: '-------' + (config.sensorValue ?? '') + '------', sensorEinheit: '', sensorValueType: '',sensorSource: 'System'
                };
            }        
            else if (config.sensorId === 'ZWZZaehlerPower') {
                const inData = data['ZWZZaehlerPowerIn'];
                const outData = data['ZWZZaehlerPowerOut'];
                if (inData && outData) {
                    const sensorValue = Number(outData.sensorValue) - Number(inData.sensorValue);
                    const iconColor = sensorValue >= 0 ? 'green' : 'red';
                    config.iconColor = iconColor;
                    sensor = { time: inData.time, label: config.sensorId, sensorTitle: 'SWR akt. Import/Export', sensorId: config.sensorId, sensorValue, sensorEinheit: inData.sensorEinheit,
                        sensorValueType: '',sensorSource: 'IQbox'
                    };
                }
            }
            // Spezialfall: ZWZZaehlerTotalPVEnergie berechnen
            else if (config.sensorId === 'ZWZZaehlerTotalPVEnergie') {
                const imp = data['ZWZZaehlerTotalPVEnergieImport'];
                const exp = data['ZWZZaehlerTotalPVEnergieExport'];
                if (imp && exp) {
                    const sensorValue = Number(exp.sensorValue) - Number(imp.sensorValue);
                    const iconColor = sensorValue >= 0 ? 'green' : 'red';
                    config.iconColor = iconColor;
                    sensor = { time: imp.time, label: config.sensorId, sensorTitle: 'Ges. Import/Export', sensorId: config.sensorId, sensorValue: `${imp.sensorValue}/${exp.sensorValue}`, sensorEinheit: imp.sensorEinheit,
                        sensorValueType: '', sensorSource: 'IQbox'
                    };
                }
            }
            // Wenn immer noch nicht gefunden → Warnung + return
            if (sensor === undefined) {
                console.warn(`Sensor mit ID ${config.sensorId} nicht gefunden`);
                return;
            }
        }
        // Farbanpassung für Heizstab booster
        if (config.sensorId === 'ELaktboostactive') {
            const val = parseFloat(sensor.sensorValue);
            if (val < 0) {
                config.iconColor = 'red';
            } else if (val === 0) {
                config.iconColor = 'gray';
            } else if (val === 1 || val === 2) {
                config.iconColor = 'green';
                sensor.sensorTitle = `${sensor.sensorTitle} steuerung von Heizstabserver`;
            } else {
                config.iconColor = 'blue';
                sensor.sensorTitle = `${sensor.sensorTitle} steuerung von Heizstabserver plus Smartbox`;
            }
        }
        // Farbanpassung für Heizstab-Server
        if (config.sensorId === 'RaspberryCheckHeizstabServer') {
            config.iconColor = parseFloat(sensor.sensorValue) >= 0 ? 'green' : 'red';
            config.textColor = parseFloat(sensor.sensorValue) >= 0 ? 'green' : 'red';
        }
        // Farbanpassung für Akku laden
        if (config.sensorId === 'IQbattery_94_battery_power') {
            config.iconColor = parseFloat(sensor.sensorValue) >= 0 ? 'green' : 'red';
            config.textColor = parseFloat(sensor.sensorValue) >= 0 ? 'green' : 'red';
        }
        
        if (config.sensorId === 'RaspberryHeizstabServerProtokoll') {
            sensor.sensorValue = '<br>'+sensor.sensorValue;
            var regex = /(error|fehler)/i; // Suchregel
            var hasError = regex.test(sensor.sensorValue);
            if (hasError) {
                config.iconColor = 'red';
                config.textColor = 'red';
            }
        }
        if (config.sensorId === 'RaspberrycheckSensorCollectorServer') {
            sensor.sensorValue = 'Error: '+sensor.sensorValue;
        }
        if (config.sensorId === 'RaspberrycheckPlattenbelegung') {
            const valObj = data['RaspberrycheckPlattenbelegung'];
            const jsonString = valObj.sensorValue;
            let jsndata;
            try {
                jsndata = typeof jsonString === 'string' ? JSON.parse(jsonString) : jsonString;
            } catch (e) {
                console.error("Fehler beim Parsen:", e);
                jsndata = [];
            }
            config.extraText = '';
            jsndata.forEach(item => {
                Object.entries(item).forEach(([key, val]) => {
                    if (config.extraText) {   // nur <br> anhängen, wenn schon Text vorhanden ist
                       //config.extraText += '<br>';
                       config.extraText += ' ';
                }
                //config.extraText = (config.extraText || '') + `${key}: ${val}`;
                //console.log(`${key}: ${val}`);
                });
            });
            //console.log('---------------extraText '+config.extraText);
        }        
        // Beschreibung für Anzeige mit CohItem
        config.description = `${sensor.sensorTitle ? sensor.sensorTitle + ':' : ''} ${sensor.sensorValue ?? ''} ${sensor.sensorEinheit ?? ''} ${config.extraText ?? ''}`.trim();

        config.sensorValue = sensor.sensorValue ?? 0;
    });

    (function waitForApp(maxAttempts = 50, attempt = 1) {
        if (typeof window.RadialGauge !== 'undefined') {
            const wrapper = document.getElementById('wrapper_<?= $this->chartId ?>');
            if (!wrapper) {
                console.error('Wrapper nicht gefunden!');
                return;
            }

            let allHtml = '';
            let toggleHtml = '';
            let togglecollect = 0;
            const gaugeInitList = [];

            sensorConfig.forEach((config, index) => {     // index ist der positionsindex in sensorConfig
                const item = new CohItem();
                const gaugeId = `gauge-<?= $this->chartId ?>-${index}`;
    
                item.setAll({
                    ...config,
                    gaugeId
                });
                if (config.iconType === 'togglestart') {
                    togglecollect = 1;                
                    toggleHtml += item.renderAsHtmlString();
                    //console.log('togglestart' + toggleHtml);
                } else if (config.iconType === 'toggleend') {
                    togglecollect = 0;                
                    toggleHtml += item.renderAsHtmlString();
                    //console.log('toggleend' + toggleHtml);
                    allHtml += toggleHtml;
                    toggleHtml = '';
                } else {
                    if (togglecollect == 0) {
                        allHtml += item.renderAsHtmlString();
                    } else {
                        toggleHtml += item.renderAsHtmlString();
                    }
                }

                if (config.iconType === 'gauge') {
                    gaugeInitList.push({ gaugeId, iconSize: config.iconSize || 80, sensorValue: config.sensorValue });     // Gauge daten in gaugeInitList merken
                }
            });

            wrapper.insertAdjacentHTML('beforeend', allHtml);


            // Nun die Gauges initialisieren
            gaugeInitList.forEach(({ gaugeId, iconSize, sensorValue }) => {
                const canvas = document.getElementById(gaugeId);
                    if (!canvas) return;                               // kein gauge

                const gauge = new RadialGauge(Object.assign({}, RadialGauge.prototype.options, {
                    renderTo: canvas,
                    width: iconSize,
                    height: iconSize,
                    value: Number(sensorValue)
                }));
                gauge.draw();
            });

        } else if (attempt < maxAttempts) {
            setTimeout(() => waitForApp(maxAttempts, attempt + 1), 50);
        } else {
            console.error(`Gauge konnte nach ${maxAttempts} Versuchen nicht geladen werden. Abbruch.`);
        }
    })();
  </script>
</div>
